{"noir_version":"0.33.0+325dac54efb6f99201de9fdeb0a507d45189607d","hash":12912346857875228547,"abi":{"parameters":[{"name":"a","type":{"kind":"field"},"visibility":"private"},{"name":"b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"29":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\nuse crate::hash::poseidon::PoseidonConfig;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(\n        consts::x5_2_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(\n        consts::x5_3_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(\n        consts::x5_4_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(\n        consts::x5_5_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(\n        consts::x5_6_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(\n        consts::x5_7_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(\n        consts::x5_8_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(\n        consts::x5_9_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(\n        consts::x5_10_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(\n        consts::x5_11_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(\n        consts::x5_12_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(\n        consts::x5_13_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(\n        consts::x5_14_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(\n        consts::x5_15_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(\n        consts::x5_16_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(\n        consts::x5_17_config(),\n        state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"30":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\nmod perm;\nmod consts;\n\nuse crate::hash::poseidon::{PoseidonConfig, absorb};\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of §3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"31":{"source":"mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::field::modulus_num_bits;\nuse crate::hash::Hasher;\nuse crate::default::Default;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\nstruct PoseidonConfig<let T: u32, let N: u32, let X: u32> { \n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n     // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X]\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T]\n) -> [Field; T] {\n    let PoseidonConfig {t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } = pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf/2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf/2+1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O] // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i+1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\n// Check security of sponge instantiation\nfn check_security(rate: Field, width: Field, security: Field) -> bool {\n    let n = modulus_num_bits();\n\n    ((n - 1) as Field * (width - rate) / 2) as u8 > security as u8\n}\n\nstruct PoseidonHasher{\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        } \n        if len == 2 {\n            result = bn254::hash_2([self._state[0],self._state[1]]);\n        } \n        if len == 3 {\n            result = bn254::hash_3([self._state[0],self._state[1],self._state[2]]);\n        } \n        if len == 4 {\n            result = bn254::hash_4([self._state[0],self._state[1],self._state[2],self._state[3]]);\n        } \n        if len == 5 {\n            result = bn254::hash_5([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4]]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5]]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6]]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7]]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8]]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9]]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10]]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11]]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12]]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13]]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13], self._state[14]]);\n        }\n        \n        result\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher{\n    fn default() -> Self{\n        PoseidonHasher{\n            _state: &[],\n        }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a, 0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29, 0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c\n            ];\n            assert_eq(expected, poseidon::bn254::perm::x5_3(state), \"Failed to reproduce output for [0, 1, 2]\");\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465, 0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d, 0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907, 0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e, 0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7\n            ];\n            assert_eq(\n                expected, poseidon::bn254::perm::x5_5(state), \"Failed to reproduce output for [0, 1, 2, 3, 4]\"\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"57":{"source":"// Import the Poseidon hash function\nuse dep::std::hash::poseidon::bn254;\n\nfn main(a: Field, b: Field) -> pub Field {\n    // Compute the hash of two field elements\n    let hash_result = bn254::hash_2([a, b]);\n\n    // Return the hash as a public output\n    hash_result\n}\n","path":"/Users/mkaihara/dev/zk-merkle-proofs-noir/generate_outputs/src/main.nr"}},"names":["main"]}